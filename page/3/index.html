
 <!DOCTYPE HTML>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  
    <title>LC的笔记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="zlc">
    
    <meta name="description" content="整理日常的学习内容">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="LC的笔记" title="LC的笔记"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="LC的笔记">LC的笔记</a></h1>
				<h2 class="blog-motto">好记性不如烂笔头</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main">

  <section class="post" itemscope itemprop="blogPost">
  
    <a href="/2015/04/27/Java/Concurrent/Java多线程设计模式/" title="Java多线程设计模式" itemprop="url">
  
    <h1 itemprop="name">Java多线程设计模式</h1>
    
     
           <p itemprop="description" >这是《Java多线程设计模式》书中的部分读书笔记。

double和long的操作并不是原子性的
Java语言中double和long类型的操作并不是原子的，例如对于变量longField，某个线程操作：
1longField = 123L;

而另外一个线程操作：
1longF</p>
        
    
    <time datetime="2015-04-27T11:05:15.000Z" itemprop="datePublished">4月 27 2015</time>
  </a>
</section>

  <section class="post" itemscope itemprop="blogPost">
  
    <a href="/2015/04/27/Java/Concurrent/JUC API参考资料/" title="JUC API参考资料" itemprop="url">
  
    <h1 itemprop="name">JUC API参考资料</h1>
    
     
           <p itemprop="description" >网络资料
JUC API的系列文章目录，非常好： http://www.blogjava.net/xylz/archive/2010/07/08/325587.html
API作者Doug lea的The java.util.concurrent Synchronizer Fra</p>
        
    
    <time datetime="2015-04-27T11:05:15.000Z" itemprop="datePublished">4月 27 2015</time>
  </a>
</section>

  <section class="post" itemscope itemprop="blogPost">
  
    <a href="/2015/04/27/Java/设计模式/门面模式/" title="门面模式" itemprop="url">
  
    <h1 itemprop="name">门面模式</h1>
    
     
           <p itemprop="description" >概述
门面设计模式，也叫Facade Pattern。
应用场景
系统中的模块之间需要相互通信，但为了安全性或封装性等，每个模块又不想把自己的内部属性和方法过多的暴露给其它模块。这时可以为每个模块设计一个门面类，该门面类保含对模块的一个引用，并且只暴露别的模块感兴趣的方法。在相互</p>
        
    
    <time datetime="2015-04-27T11:05:15.000Z" itemprop="datePublished">4月 27 2015</time>
  </a>
</section>

  <section class="post" itemscope itemprop="blogPost">
  
    <a href="/2015/04/27/Java/设计模式/适配器模式/" title="适配器模式" itemprop="url">
  
    <h1 itemprop="name">适配器模式</h1>
    
     
           <p itemprop="description" >概述
适配器模式（adapter pattern），属于结构型模式，有时候也称包装样式或者包装。
实现方式
适配器模式有2种实现方式，一种是类适配器模式，即实现类继承一个父类并实现一个接口类，然后通过调用父类的方法去完成重写接口的方法。另一种是对象适配模式，即实现类只实现一个接口</p>
        
    
    <time datetime="2015-04-27T11:05:15.000Z" itemprop="datePublished">4月 27 2015</time>
  </a>
</section>

  <section class="post" itemscope itemprop="blogPost">
  
    <a href="/2015/04/27/Java/设计模式/责任链模式/" title="责任链模式" itemprop="url">
  
    <h1 itemprop="name">责任链模式</h1>
    
     
           <p itemprop="description" >概述
责任链模式就是很多对象由每个对象对其下家的引用而连接起来形成的一条链，请求在这条链中传递，直到链上的某个对象处理此请求，或者每个对象都可以处理请求，并传递给下家，直到处理完成。这样发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，使得系统可以在不影响客户端的情况</p>
        
    
    <time datetime="2015-04-27T11:05:15.000Z" itemprop="datePublished">4月 27 2015</time>
  </a>
</section>

  <section class="post" itemscope itemprop="blogPost">
  
    <a href="/2015/04/27/Java/设计模式/观察者模式/" title="观察者模式" itemprop="url">
  
    <h1 itemprop="name">观察者模式</h1>
    
     
           <p itemprop="description" >概述
观察者模式（有时又被称为发布/订阅模式）。这个模式允许一个观察者(the observer)观察一个主题(the subject)。observer通过注册接收主题subject发布的事件，而当主题发生变化时则会通知每个观察者中。
示例
123456789101112131</p>
        
    
    <time datetime="2015-04-27T11:05:15.000Z" itemprop="datePublished">4月 27 2015</time>
  </a>
</section>

  <section class="post" itemscope itemprop="blogPost">
  
    <a href="/2015/04/27/Java/设计模式/装饰模式/" title="装饰模式" itemprop="url">
  
    <h1 itemprop="name">装饰模式</h1>
    
     
           <p itemprop="description" >前言：利用 Filter 进行敏感字符过滤时发现没有 set 方法对参数进行修改，只有 get 方法获取参数。所以可以利用装饰模式增强 get 方法的功能，
概述
什么是装饰模式：对一个类中的某个方法的功能进行增强。
一般过程
1）实现与被增强对象共同的接口/抽象类或者继承该接口</p>
        
    
    <time datetime="2015-04-27T11:05:15.000Z" itemprop="datePublished">4月 27 2015</time>
  </a>
</section>

  <section class="post" itemscope itemprop="blogPost">
  
    <a href="/2015/04/27/Java/设计模式/策略模式/" title="策略模式" itemprop="url">
  
    <h1 itemprop="name">策略模式</h1>
    
     
           <p itemprop="description" >概述
GOF中对策略模式的定义：策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。
理解
策略模式的主要应用场景就是：程序某特定功能在不同情况下采用不同的策略（算法），在运行时可以动态选择采用的策略。也就是把</p>
        
    
    <time datetime="2015-04-27T11:05:15.000Z" itemprop="datePublished">4月 27 2015</time>
  </a>
</section>

  <section class="post" itemscope itemprop="blogPost">
  
    <a href="/2015/04/27/Java/设计模式/模板模式/" title="模板模式" itemprop="url">
  
    <h1 itemprop="name">模板模式</h1>
    
     
           <p itemprop="description" >模板模式
方法提供了大体的操作模板，但是具体的处理可以根据传递的参数规定。
示例代码
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253</p>
        
    
    <time datetime="2015-04-27T11:05:15.000Z" itemprop="datePublished">4月 27 2015</time>
  </a>
</section>

  <section class="post" itemscope itemprop="blogPost">
  
    <a href="/2015/04/27/Java/设计模式/桥接模式/" title="桥接模式" itemprop="url">
  
    <h1 itemprop="name">桥接模式</h1>
    
     
           <p itemprop="description" >概述
软件设计中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，那么如何应对这种“多维度的变化”？这里介绍的桥接模式就是为了适应类的变化。
具体实现
桥接模式是用于“把抽象和实现分开，这样它们就能独立变化”。 桥接模式使用了封装、聚合，可以用继承将不同的功能拆分为不同的类。</p>
        
    
    <time datetime="2015-04-27T11:05:15.000Z" itemprop="datePublished">4月 27 2015</time>
  </a>
</section>


  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Android/" title="Android">Android<sup>3</sup></a></li>
		
			<li><a href="/tags/Concurrent/" title="Concurrent">Concurrent<sup>7</sup></a></li>
		
			<li><a href="/tags/ConcurrentAPI/" title="ConcurrentAPI">ConcurrentAPI<sup>1</sup></a></li>
		
			<li><a href="/tags/Cookie-Session/" title="Cookie&amp;Session">Cookie&amp;Session<sup>2</sup></a></li>
		
			<li><a href="/tags/Hibernate/" title="Hibernate">Hibernate<sup>5</sup></a></li>
		
			<li><a href="/tags/JDBC/" title="JDBC">JDBC<sup>3</sup></a></li>
		
			<li><a href="/tags/JSP-Servlet/" title="JSP&amp;Servlet">JSP&amp;Servlet<sup>5</sup></a></li>
		
			<li><a href="/tags/Java/" title="Java">Java<sup>3</sup></a></li>
		
			<li><a href="/tags/Maven/" title="Maven">Maven<sup>4</sup></a></li>
		
			<li><a href="/tags/MyBatis/" title="MyBatis">MyBatis<sup>2</sup></a></li>
		
			<li><a href="/tags/NIO/" title="NIO">NIO<sup>6</sup></a></li>
		
			<li><a href="/tags/Network/" title="Network">Network<sup>2</sup></a></li>
		
			<li><a href="/tags/Oracle/" title="Oracle">Oracle<sup>6</sup></a></li>
		
			<li><a href="/tags/SQL/" title="SQL">SQL<sup>6</sup></a></li>
		
			<li><a href="/tags/Spring/" title="Spring">Spring<sup>5</sup></a></li>
		
			<li><a href="/tags/SpringMVC/" title="SpringMVC">SpringMVC<sup>4</sup></a></li>
		
			<li><a href="/tags/Struts2/" title="Struts2">Struts2<sup>5</sup></a></li>
		
			<li><a href="/tags/设计模式/" title="设计模式">设计模式<sup>12</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://yoursite.com" target="_blank" title="zlc">zlc</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>







  </body>
 </html>
