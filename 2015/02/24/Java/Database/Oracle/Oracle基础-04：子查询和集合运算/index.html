
 <!DOCTYPE HTML>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  
    <title>Oracle基础-04：子查询和集合运算 | LC的笔记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="zlc">
    
    <meta name="description" itemprop="description" content="首先介绍单行和多行子查询，并且总结了一些注意事项。接着介绍了rownum和分页查询的方法，比较了几种分页查询的效率。最后介绍集合查询。">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="LC的笔记" title="LC的笔记"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="LC的笔记">LC的笔记</a></h1>
				<h2 class="blog-motto">好记性不如烂笔头</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/02/24/Java/Database/Oracle/Oracle基础-04：子查询和集合运算/" title="Oracle基础-04：子查询和集合运算" itemprop="url">Oracle基础-04：子查询和集合运算</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="zlc">zlc</a>
    </p>
  <p class="article-time">
    <time datetime="2015-02-24T04:46:25.000Z" itemprop="datePublished">2月 24 2015</time>
    Updated:<time datetime="2015-02-24T05:23:34.000Z" itemprop="dateModified">2月 24 2015</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#子查询"><span class="toc-number">1.</span> <span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单行子查询"><span class="toc-number">1.1.</span> <span class="toc-text">单行子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多行子查询"><span class="toc-number">1.2.</span> <span class="toc-text">多行子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用子查询的一些注意事项"><span class="toc-number">1.3.</span> <span class="toc-text">使用子查询的一些注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可以在主查询的SELECT，FROM，WHERE，HAVING后面均可放置子查询语句，但SELECT后面只能放置单行子查询，例如："><span class="toc-number">1.3.1.</span> <span class="toc-text">可以在主查询的SELECT，FROM，WHERE，HAVING后面均可放置子查询语句，但SELECT后面只能放置单行子查询，例如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NOT_IN空值问题：使用NOT_IN的时候后面的列表不可以有空值。例如："><span class="toc-number">1.3.2.</span> <span class="toc-text">NOT IN空值问题：使用NOT IN的时候后面的列表不可以有空值。例如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主查询和子查询可以不是同一张表，但这时候最好用多表查询实现。例如："><span class="toc-number">1.3.3.</span> <span class="toc-text">主查询和子查询可以不是同一张表，但这时候最好用多表查询实现。例如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一般不在子查询中使用ORDER_BY子句，但在top-n分析中，必须使用ORDER_BY子句。例如："><span class="toc-number">1.3.4.</span> <span class="toc-text">一般不在子查询中使用ORDER BY子句，但在top-n分析中，必须使用ORDER BY子句。例如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主查询和子查询参数传递的问题"><span class="toc-number">1.3.5.</span> <span class="toc-text">主查询和子查询参数传递的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主查询和子查询的执行顺序"><span class="toc-number">1.3.6.</span> <span class="toc-text">主查询和子查询的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rownum"><span class="toc-number">1.4.</span> <span class="toc-text">rownum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页查询"><span class="toc-number">1.5.</span> <span class="toc-text">分页查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合运算"><span class="toc-number">2.</span> <span class="toc-text">集合运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MINUS"><span class="toc-number">2.1.</span> <span class="toc-text">MINUS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNION"><span class="toc-number">2.2.</span> <span class="toc-text">UNION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNION_ALL"><span class="toc-number">2.3.</span> <span class="toc-text">UNION ALL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INTERSECT"><span class="toc-number">2.4.</span> <span class="toc-text">INTERSECT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MINUS和NOT_IN"><span class="toc-number">2.5.</span> <span class="toc-text">MINUS和NOT IN</span></a></li></ol></li></ol>
		</div>
		
		<h2 id="子查询">子查询</h2>
<p>负责的查询操作中一般用到子查询。例如从employees表中查询工资比Abel高的人的记录，这时候就要先查询出Abel的工资（这就是子查询），然后再查询出来其他人。<br>可以这么概括：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span>    select_list</span></div><div class="line"><span class="keyword">FROM</span>    <span class="keyword">table</span></div><div class="line"><span class="keyword">WHERE</span>    expr operator</div><div class="line">             (<span class="keyword">SELECT</span>    select_list</div><div class="line">                <span class="keyword">FROM</span>        <span class="keyword">table</span>);</div></pre></td></tr></table></figure>

<p>其中括号中的就是子查询。</p>
<p>子查询包括：</p>
<ul>
<li><p>单行子查询，返回一行记录，使用单行比较操作符。</p>
</li>
<li><p>多行子查询，返回多行记录，使用多行比较操作符。</p>
</li>
</ul>
<h3 id="单行子查询">单行子查询</h3>
<p>单行比较操作符为：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等</td>
</tr>
<tr>
<td>&lt;&gt; 或者 !=</td>
<td>不等于</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id 和工资</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> last_name, job_id, salary</span></div><div class="line">  <span class="keyword">FROM</span> employees</div><div class="line"><span class="keyword">WHERE</span> job_id = (<span class="keyword">SELECT</span> job_id <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id = <span class="number">141</span>)</div><div class="line">   <span class="keyword">AND</span> salary &gt; (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id = <span class="number">143</span>);</div></pre></td></tr></table></figure>

<h3 id="多行子查询">多行子查询</h3>
<p>多行操作符为：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>等于列表中任意一个</td>
</tr>
<tr>
<td>not in</td>
<td>不等于列表中任意一个</td>
</tr>
<tr>
<td>all</td>
<td>和子查询返回的<strong>所有</strong>比较</td>
</tr>
<tr>
<td>any</td>
<td>和子查询返回的<strong>某一个</strong>比较</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>any操作符是和子查询结果中某一个记录比较，例如：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> *</span></div><div class="line">  <span class="keyword">FROM</span> employees</div><div class="line"><span class="keyword">WHERE</span> salary &gt; <span class="keyword">ANY</span></div><div class="line">(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id = <span class="number">100</span>);</div></pre></td></tr></table></figure>

<p>这时候等价于：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> *</span></div><div class="line">  <span class="keyword">FROM</span> employees</div><div class="line"><span class="keyword">WHERE</span> salary &gt;</div><div class="line">       (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id = <span class="number">100</span>);</div></pre></td></tr></table></figure>

<ul>
<li>all操作符和子查询结果中所有记录比较，例如：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> *</span></div><div class="line">  <span class="keyword">FROM</span> employees</div><div class="line"><span class="keyword">WHERE</span> salary &gt; <span class="keyword">ALL</span></div><div class="line">(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id = <span class="number">100</span>);</div></pre></td></tr></table></figure>

<p>这时候等价于：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> *</span></div><div class="line">  <span class="keyword">FROM</span> employees</div><div class="line"><span class="keyword">WHERE</span> salary &gt;</div><div class="line">       (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id = <span class="number">100</span>);</div></pre></td></tr></table></figure>

<h3 id="使用子查询的一些注意事项">使用子查询的一些注意事项</h3>
<h4 id="可以在主查询的SELECT，FROM，WHERE，HAVING后面均可放置子查询语句，但SELECT后面只能放置单行子查询，例如：">可以在主查询的SELECT，FROM，WHERE，HAVING后面均可放置子查询语句，但SELECT后面只能放置单行子查询，例如：</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> department_id,</span></div><div class="line">       salary,</div><div class="line">       (<span class="keyword">SELECT</span> job_id <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id = <span class="number">120</span>)</div><div class="line">  <span class="keyword">FROM</span> employees;</div></pre></td></tr></table></figure>

<h4 id="NOT_IN空值问题：使用NOT_IN的时候后面的列表不可以有空值。例如：">NOT IN空值问题：<strong>使用NOT IN的时候后面的列表不可以有空值</strong>。例如：</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 列表没有空值，有返回结果</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dual <span class="keyword">WHERE</span> dummy <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">'Y'</span>);</span></div><div class="line"><span class="comment">-- 列表有空值，没有返回结果 </span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dual <span class="keyword">WHERE</span> dummy <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">'Y'</span>, <span class="literal">NULL</span>);</span></div></pre></td></tr></table></figure>

<p>这是因为NOT IN等同于<code>&lt;&gt; all</code>，也就是不等于列表中的所有值，而与NULL的比较运算都为空。<br>相反对应IN操作，后面的列表则可以有空值，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 有返回记录</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dual <span class="keyword">WHERE</span> dummy <span class="keyword">IN</span> (<span class="string">'X'</span>, <span class="literal">NULL</span>, <span class="string">'Y'</span>);</span></div><div class="line"><span class="comment">-- 有返回记录</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dual <span class="keyword">WHERE</span> dummy <span class="keyword">IN</span> (<span class="string">'X'</span>, <span class="number">3</span>);</span></div><div class="line"><span class="comment">-- 无返回记录</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dual <span class="keyword">WHERE</span> dummy <span class="keyword">IN</span> (<span class="string">'k'</span>);</span></div><div class="line"><span class="comment">-- 语法错误</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dual <span class="keyword">WHERE</span> dummy <span class="keyword">IN</span> (<span class="string">'k'</span>, <span class="number">3</span>);</span></div></pre></td></tr></table></figure>

<p>这是因为IN等同于<code>= any</code>，也就是和列表中的某个值进行比较，这些值可以为NULL。</p>
<h4 id="主查询和子查询可以不是同一张表，但这时候最好用多表查询实现。例如：">主查询和子查询可以不是同一张表，但这时候最好用多表查询实现。例如：</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> *</span></div><div class="line">  <span class="keyword">FROM</span> employees</div><div class="line"><span class="keyword">WHERE</span> department_id =</div><div class="line">       (<span class="keyword">SELECT</span> department_id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> department_name = <span class="string">'IT'</span>);</div><div class="line"><span class="comment">-- 可以用多表查询实现 </span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> employee_id, first_name</span></div><div class="line">  <span class="keyword">FROM</span> employees e, departments d</div><div class="line"><span class="keyword">WHERE</span> e.department_id = d.department_id</div><div class="line">   <span class="keyword">AND</span> d.department_name = <span class="string">'IT'</span>;</div></pre></td></tr></table></figure>

<h4 id="一般不在子查询中使用ORDER_BY子句，但在top-n分析中，必须使用ORDER_BY子句。例如：">一般不在子查询中使用ORDER BY子句，但在top-n分析中，必须使用ORDER BY子句。例如：</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> rownum, salary, last_name</span></div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>)</div><div class="line"><span class="keyword">WHERE</span> rownum &lt;= <span class="number">3</span>;</div></pre></td></tr></table></figure>

<h4 id="主查询和子查询参数传递的问题">主查询和子查询参数传递的问题</h4>
<p>主查询的列可以传递给子查询作为条件使用。<br>例如下面的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> tt.department_id,</span></div><div class="line">       tt.last_name,</div><div class="line">       tt.salary,</div><div class="line">       (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(e1.salary)</div><div class="line">          <span class="keyword">FROM</span> employees e1</div><div class="line">         <span class="keyword">WHERE</span> e1.department_id = tt.department_id)</div><div class="line">  <span class="keyword">FROM</span> employees tt</div><div class="line"><span class="keyword">WHERE</span> tt.salary &gt; (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(e2.salary)</div><div class="line">                   <span class="keyword">FROM</span> employees e2</div><div class="line">                  <span class="keyword">WHERE</span> e2.department_id = tt.department_id)</div></pre></td></tr></table></figure>

<p>主查询的SELECT中用到了子查询并使用主查询表的列，同样WHERE子句也用到主查询的列。</p>
<h4 id="主查询和子查询的执行顺序">主查询和子查询的执行顺序</h4>
<p>一般而言先执行子查询。但对于将主查询的某个值作为参数传递给子查询使用，可理解为先执行了主查询。<br>例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--查询employees 表中工资大于本部门平均工资的员工信息</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> e.department_id, e.last_name, e.salary, d.avgsal</span></div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> department_id, <span class="keyword">AVG</span>(salary) avgsal</div><div class="line">          <span class="keyword">FROM</span> employees</div><div class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) d,</div><div class="line">       employees e</div><div class="line"><span class="keyword">WHERE</span> d.department_id = e.department_id</div><div class="line">   <span class="keyword">AND</span> e.salary &gt; d.avgsal</div></pre></td></tr></table></figure>

<p>这里主查询用到了子查询的AVG(salary)值作为条件，所以要先执行括号中的子查询得到该值（可以查看执行计划确认）。</p>
<h3 id="rownum">rownum</h3>
<blockquote>
<p>参考资料<br><a href="http://www.cnblogs.com/java0819/archive/2011/08/03/2146205.html" target="_blank" rel="external">Oracle中的rownum不能使用大于&gt;的问题</a></p>
</blockquote>
<p>rownum是伪列，可以这样理解rownum的比较运算：在第一条记录产生后便进行判断，若不符合即丢弃。</p>
<ul>
<li><strong>所以使用rownum进行大于、大于等于、=2、between and 之类的比较操作时，是没有返回结果的。</strong><br>例如：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 查询employees所有记录</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> ROWNUM &gt; <span class="number">0</span>;</span></div><div class="line"><span class="comment">-- 同样查询employees所有记录</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> ROWNUM &gt;= <span class="number">1</span>;</span></div><div class="line"><span class="comment">-- 有一条记录</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> ROWNUM = <span class="number">1</span>;</span></div><div class="line"><span class="comment">-- 没有记录</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> ROWNUM = <span class="number">2</span>;</span></div><div class="line"><span class="comment">-- 没有记录</span></div><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> ROWNUM &gt; <span class="number">3</span>;</span></div></pre></td></tr></table></figure>

<p><strong>因为rownum总是从1开始的，第一条不满足去掉的话，第二条的rownum 又成了1。依此类推，所以永远没有满足条件的记录。</strong></p>
<ul>
<li>因此一般只能用于小于、小于等于这些比较操作：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> ROWNUM &lt; <span class="number">4</span>;</span></div></pre></td></tr></table></figure>

<ul>
<li>如果需要用到rownum，那么先把rownum和其它列查询出来作为子查询结果集中的固定列，这样就可以像其它列一样进行各种操作了。<br>例如：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span></div><div class="line">(</div><div class="line"><span class="keyword">SELECT</span> ROWNUM rn, e.* <span class="keyword">FROM</span> employees e</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e.employee_id <span class="keyword">DESC</span></div><div class="line">) tt</div><div class="line"><span class="keyword">WHERE</span> tt.rn = <span class="number">2</span>;</div></pre></td></tr></table></figure>

<p>或者是下面要说明的分页操作。</p>
<h3 id="分页查询">分页查询</h3>
<blockquote>
<p>参考资料<br><a href="http://database.51cto.com/art/200904/118737.htm" target="_blank" rel="external">详解Oracle的几种分页查询语句</a><br><a href="http://www.111cn.net/database/Oracle/46274.htm" target="_blank" rel="external">oracle分页查询sql原理与语句</a></p>
</blockquote>
<ul>
<li>如果不需要ORDER BY操作，那么可以使用下面的方法：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> ee.*</span></div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> rownum rn, e.* <span class="keyword">FROM</span> employees e <span class="keyword">WHERE</span> rownum &lt; <span class="number">20</span>) ee</div><div class="line"><span class="keyword">WHERE</span> ee.rn &gt; <span class="number">10</span>;</div></pre></td></tr></table></figure>

<p>这时候是最高效的方法，只查询了2次。</p>
<ul>
<li>如果需对排序结果进行分页，那么需要使用下面的方法：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> ee.*</span></div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> rownum rn, e.*</div><div class="line">          <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> employee_id <span class="keyword">DESC</span>) e</div><div class="line">         <span class="keyword">WHERE</span> rownum &lt; <span class="number">20</span>) ee</div><div class="line"><span class="keyword">WHERE</span> rn &gt; <span class="number">10</span>;</div></pre></td></tr></table></figure>

<p>为什么不能用上面的方法？<strong>这是由于ORDER BY的优先级比rownum低的原因</strong>。<br>如果使用上面的方法，那么内层查询大概是这样的：<code>SELECT rownum rn, e.* FROM employees e WHERE rownum &lt; 20 ORDER BY e.employee_id DESC</code>。这时候的结果是对rownum小于20的结果集进行排序，显然是不对的！<br>所以要在最内层先进行ORDER BY操作。</p>
<ul>
<li>还有一种比较低效的方法：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> *</span></div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> rownum rn, e.* <span class="keyword">FROM</span> employees e) ee</div><div class="line"><span class="keyword">WHERE</span> rn <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">AND</span> <span class="number">20</span>;</div></pre></td></tr></table></figure>

<p>这种查询看起来只用来2次查询，为什么比上面的方法低效呢？<br><strong>这是由于CBO优化模式下，Oracle可以将外层的查询条件推到内层查询中，以提高内层查询的执行效率。对于第二个查询语句，第二层的查询条件<code>WHERE rownum &lt; 20</code>就可以被Oracle推入到内层查询中，这样Oracle查询的结果一旦超过了rownum限制条件，就终止查询将结果返回了。</strong><br>而当前的查询语句由于条件<code>WHERE rn BETWEEN 10 AND 20</code>是存在于查询的最外层，而Oracle无法将查询条件推到最内层。因此Oracle最内层返回的是所有满足条件的数据，数据的过滤在最外层完成，显然这个效率要比第一个查询低得多。</p>
<h2 id="集合运算">集合运算</h2>
<p>参与运算的各个集合必须要列数相同且类型一致。<br>集合函数包括：<code>MINUS</code>、<code>UNION</code>、<code>UNION ALL</code>、<code>INTERSECT</code>。</p>
<h3 id="MINUS">MINUS</h3>
<p>找到两个给定的数值集合之间的差异，意味着找到一个数值集合，其中的元素仅存在于前一个集合中，而不存在于另一个集合中。<br>示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> d.department_id <span class="keyword">FROM</span> departments d</span></div><div class="line">MINUS</div><div class="line"><span class="keyword">SELECT</span> e.department_id <span class="keyword">FROM</span> employees e;</div></pre></td></tr></table></figure>

<p><strong>注意这是有前后顺序的，把上面的SELECT语句调用后结果是不一样的！</strong></p>
<h3 id="UNION">UNION</h3>
<p>UNION连接查询的两张表中相同列名的数据的并集。<br>示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> d.department_id <span class="keyword">FROM</span> departments d</span></div><div class="line"><span class="keyword">UNION</span></div><div class="line"><span class="keyword">SELECT</span> e.department_id <span class="keyword">FROM</span> employees e;</div></pre></td></tr></table></figure>

<h3 id="UNION_ALL">UNION ALL</h3>
<p>UNION ALL连接查询两张表中相同列名的所有数据，与UNION不同的是它不去除重复数据。<br>示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> d.department_id <span class="keyword">FROM</span> departments d</span></div><div class="line"><span class="keyword">UNION</span></div><div class="line"><span class="keyword">SELECT</span> e.department_id <span class="keyword">FROM</span> employees e;</div></pre></td></tr></table></figure>

<h3 id="INTERSECT">INTERSECT</h3>
<p>INTERSECT查询连接的两张表中相同列名的数据，查出交集的数据。</p>
<p><strong>注意和MINUS的区别：MINUS是查询在A表中但不在B表中的记录；INTERSECT是查询A表和B表中相同的数据。</strong><br>示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> d.department_id <span class="keyword">FROM</span> departments d</span></div><div class="line"><span class="keyword">INTERSECT</span></div><div class="line"><span class="keyword">SELECT</span> e.department_id <span class="keyword">FROM</span> employees e;</div></pre></td></tr></table></figure>

<h3 id="MINUS和NOT_IN">MINUS和NOT IN</h3>
<p>MINUS的逻辑可以用NOT IN实现。<br>示例：查询没有员工的部门。<br>使用MINUS实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (</span></div><div class="line"><span class="keyword">SELECT</span> d.department_id <span class="keyword">FROM</span> departments d</div><div class="line">MINUS</div><div class="line"><span class="keyword">SELECT</span> e.department_id <span class="keyword">FROM</span> employees e);</div></pre></td></tr></table></figure>

<p>实现NOT IN实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> department_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span></div><div class="line"><span class="keyword">SELECT</span> d.department_id <span class="keyword">FROM</span> departments d, employees e</div><div class="line"><span class="keyword">WHERE</span> d.department_id = e.department_id);</div></pre></td></tr></table></figure>

<p><strong>值得注意的是，NOT IN可以用”外连接+IS NULL”的方式实现。</strong></p>
<p>例如上面的例子还可以这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">SELECT</span> d.* <span class="keyword">FROM</span> departments d, employees e</span></div><div class="line"><span class="keyword">WHERE</span> d.department_id = e.department_id(+)</div><div class="line"><span class="keyword">AND</span> e.department_id <span class="keyword">IS</span> <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>

<blockquote>
<p>小结”外连接+IS NULL”实现NOT IN逻辑<br>有两个表A和表B，现在查询在A表中但不在B表中的数据。首先用左外连接得到A表中所有记录而B表没有的用NULL表示，这样再过滤出B表中IS NULL的记录就是所要的结果。</p>
</blockquote>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/Oracle/">Oracle</a><a href="/tags/SQL/">SQL</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2015/02/24/Java/Database/Oracle/Oracle基础-04：子查询和集合运算/" data-title="Oracle基础-04：子查询和集合运算 | LC的笔记" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/02/24/Java/Database/Oracle/Oracle基础-05：创建表和约束/" title="Oracle基础-05：创建表和约束.md">
  <strong>PREVIOUS:</strong><br/>
  <span>
  Oracle基础-05：创建表和约束.md</span>
</a>
</div>


<div class="next">
<a href="/2015/02/22/Java/Database/Oracle/Oracle基础-03：多表查询/"  title="Oracle基础-03：多表查询">
 <strong>NEXT:</strong><br/> 
 <span>Oracle基础-03：多表查询
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#子查询"><span class="toc-number">1.</span> <span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单行子查询"><span class="toc-number">1.1.</span> <span class="toc-text">单行子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多行子查询"><span class="toc-number">1.2.</span> <span class="toc-text">多行子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用子查询的一些注意事项"><span class="toc-number">1.3.</span> <span class="toc-text">使用子查询的一些注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可以在主查询的SELECT，FROM，WHERE，HAVING后面均可放置子查询语句，但SELECT后面只能放置单行子查询，例如："><span class="toc-number">1.3.1.</span> <span class="toc-text">可以在主查询的SELECT，FROM，WHERE，HAVING后面均可放置子查询语句，但SELECT后面只能放置单行子查询，例如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NOT_IN空值问题：使用NOT_IN的时候后面的列表不可以有空值。例如："><span class="toc-number">1.3.2.</span> <span class="toc-text">NOT IN空值问题：使用NOT IN的时候后面的列表不可以有空值。例如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主查询和子查询可以不是同一张表，但这时候最好用多表查询实现。例如："><span class="toc-number">1.3.3.</span> <span class="toc-text">主查询和子查询可以不是同一张表，但这时候最好用多表查询实现。例如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一般不在子查询中使用ORDER_BY子句，但在top-n分析中，必须使用ORDER_BY子句。例如："><span class="toc-number">1.3.4.</span> <span class="toc-text">一般不在子查询中使用ORDER BY子句，但在top-n分析中，必须使用ORDER BY子句。例如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主查询和子查询参数传递的问题"><span class="toc-number">1.3.5.</span> <span class="toc-text">主查询和子查询参数传递的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主查询和子查询的执行顺序"><span class="toc-number">1.3.6.</span> <span class="toc-text">主查询和子查询的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rownum"><span class="toc-number">1.4.</span> <span class="toc-text">rownum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页查询"><span class="toc-number">1.5.</span> <span class="toc-text">分页查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合运算"><span class="toc-number">2.</span> <span class="toc-text">集合运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MINUS"><span class="toc-number">2.1.</span> <span class="toc-text">MINUS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNION"><span class="toc-number">2.2.</span> <span class="toc-text">UNION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNION_ALL"><span class="toc-number">2.3.</span> <span class="toc-text">UNION ALL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INTERSECT"><span class="toc-number">2.4.</span> <span class="toc-text">INTERSECT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MINUS和NOT_IN"><span class="toc-number">2.5.</span> <span class="toc-text">MINUS和NOT IN</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/JDBC/" title="JDBC">JDBC<sup>3</sup></a></li>
		
			<li><a href="/tags/Java/" title="Java">Java<sup>3</sup></a></li>
		
			<li><a href="/tags/Oracle/" title="Oracle">Oracle<sup>6</sup></a></li>
		
			<li><a href="/tags/SQL/" title="SQL">SQL<sup>6</sup></a></li>
		
			<li><a href="/tags/hibernate/" title="hibernate">hibernate<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://yoursite.com" target="_blank" title="zlc">zlc</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
